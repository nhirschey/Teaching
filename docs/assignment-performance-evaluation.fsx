(**
---
title: Performance Evaluation
category: Assignments
categoryindex: 1
index: 7
---

[![Binder](img/badge-binder.svg)](https://mybinder.org/v2/gh/nhirschey/teaching/gh-pages?filepath={{fsdocs-source-basename}}.ipynb)&emsp;
[![Script](img/badge-script.svg)]({{root}}/{{fsdocs-source-basename}}.fsx)&emsp;
[![Notebook](img/badge-notebook.svg)]({{root}}/{{fsdocs-source-basename}}.ipynb)


|        | Student Name | Student Number  | 
| ------ | -----------  | --------------  |
| **1**  |              |                 |
| **2**  |              |                 |


**Signal Name (e.g., Book to Market):**

**Signal Code (e.g., be_me):**

This is an assignment. You may work in pairs (two students) using either student's signal to answer the below questions.  You will find sections labeled **Task** asking you to do each piece of analysis. Please make sure that you complete all of these tasks. Make use of the course resources and example code on the course website. It should be possible to complete all the requested tasks using information given below or somewhere on the course website.

*)

#r "nuget:FSharp.Data"
#r "nuget: FSharp.Stats"
#r "nuget: Plotly.NET, 2.0.0-preview.17"
(*** condition: ipynb ***)
#r "nuget: Plotly.NET.Interactive, 2.0.0-preview.17"

(** *)

open System
open FSharp.Data
open Plotly.NET
open FSharp.Stats

(*** condition: fsx ***)
#if FSX
fsi.AddPrinter<DateTime>(fun dt -> dt.ToString("s"))
fsi.AddPrinter<YearMonth>(fun ym -> $"{ym.Year}-{ym.Month}")
#endif // FSX

(*** condition: ipynb ***)
#if IPYNB
// Set dotnet interactive formatter to plaintext
Formatter.Register(fun (x:obj) (writer: TextWriter) -> fprintfn writer "%120A" x )
Formatter.SetPreferredMimeTypesFor(typeof<obj>, "text/plain")
// Make plotly graphs work with interactive plaintext formatter
Formatter.SetPreferredMimeTypesFor(typeof<GenericChart.GenericChart>,"text/html")
#endif // IPYNB


(**
## Load Data

First, make sure that you're referencing the correct files.

Here I'm assuming that you have a class folder with this 
notebook and these files in it. The folder hierarchy would 
look like below where you have the below files and folders accessible.

- `Common.fsx` is on the course website.
- `notebook.ipynb` is this notebook.
- `myExcessReturnPortfolios.csv` is generated by code for construction [signal portfolios](signal-portfolio.fsx). 

```code
/class
    Common.fsx
    notebook.ipynb                
    /data
        myExcessReturnPortfolios.csv
```
*)

let [<Literal>] ResolutionFolder = __SOURCE_DIRECTORY__
Environment.CurrentDirectory <- ResolutionFolder

#load "Common.fsx"
open Common

(**
We get the Fama-French 3-Factor asset pricing model data.
*)

let ff3 = French.getFF3 Frequency.Monthly

(**
### Data file
*)

let [<Literal>] myExcessReturnPortfoliosPath = "data/myExcessReturnPortfolios.csv"

(**
If my paths are correct, then this code should read the first few lines of the files.
If it doesn't show the first few lines, fix the above file paths.
*)

IO.File.ReadLines(myExcessReturnPortfoliosPath) |> Seq.truncate 5
(** *)

(** Ok, now assuming those paths were correct the below code will work. 
I will put all this prep code in one block so that it is easy to run.
*)

let myExcessReturnPortfolios = 
    CsvProvider<myExcessReturnPortfoliosPath,
                ResolutionFolder = ResolutionFolder>.GetSample()

(** Headers *)
myExcessReturnPortfolios.Headers

(** First few rows *)
myExcessReturnPortfolios.Rows
|> Seq.take 3

(** Isolate some notable portfolios.*)
type SignalPortfolioObs = 
    { Month: DateTime
      Name: string
      Return: float }
let long =
    myExcessReturnPortfolios.Rows
    |> Seq.toList
    |> List.filter (fun row -> row.Index = Some 3)
    |> List.map (fun row -> 
        { Month = row.YearMonth
          Name = "Long"
          Return = row.Ret })

let short =
    myExcessReturnPortfolios.Rows
    |> Seq.toList
    |> List.filter (fun row -> row.Index = Some 1)
    |> List.map (fun row -> 
        { Month = row.YearMonth
          Name = "Short"
          Return = row.Ret })

let shortByMonth = 
    short 
    |> List.map (fun x -> x.Month, x) 
    |> Map

let longShort =
    [ for l in long do 
        // I'm indexing into shortByMonth directly
        // rather than using Map.tryFind because
        // I am pretty confident that the short 
        // data will be there
        let s = shortByMonth[l.Month]
        { Month = l.Month
          Name = "Long-short"
          Return = l.Return - s.Return }]

(**
## Start of assignment

> **Task:** Calculate the annualized Sharpe ratios of your long, short, and long-short portfolios. 
*)
// Solution here.

(**
> **Task:** Estimate CAPM and Fama-French 3-factor models for your long-short portfolio. 
*)
// Solution here.

(**
### CAPM model evaluation.
*)

(**
> **Task:** What is the CAPM alpha for your long-short portfolio. Is it significantly different from zero? 
*)
// Solution here.

(**
> **Task:** What is the CAPM beta for your long-short portfolio. Is it significantly different from zero? 
*)
// Solution here.

(**
> **Task:** What is the information ratio for your long-short portfolio when using the CAPM model? 
*)
// Solution here.

(**
### Fama-French 3-factor model evaluation.
*)

(**
> **Task:** What is the Fama-French 3-factor model alpha for your long-short portfolio. Is it significantly different from zero? 
*)
// Solution here.

(**
> **Task:** What are the betas on the Market, HML, and SMB factors for your long-short portfolio. Are they significantly different from zero? 
*)
// Solution here.

(**
> **Task:** Based on the Market, HML, and SMB factor betas for your long-short portfolio, would you say your portfolio is more like a value portfolio, more like a growth portfolio, or neither?
*)
// Solution here.

(**
> **Task:** Based on the Market, HML, and SMB factor betas for your long-short portfolio, would you say your portfolio is more like a small-cap portfolio, more like a large-cap portfolio, or neither?
*)
// Solution here.


(**
> **Task:** What is the information ratio for your long-short portfolio when using the Fama and French 3-factor model? 
*)
// Solution here.

